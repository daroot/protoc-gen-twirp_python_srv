package main

import (
	"bytes"
	"strings"
	"unicode"

	"github.com/golang/protobuf/protoc-gen-go/descriptor"
)

type pythonSrvTemplatePresenter struct {
	proto *descriptor.FileDescriptorProto

	Version        string
	Package        string
	SourceFilename string
}

func (p *pythonSrvTemplatePresenter) Services() []*tmplService {
	services := make([]*tmplService, len(p.proto.GetService()))

	for i, svc := range p.proto.GetService() {
		services[i] = &tmplService{
			proto: svc,
			pkg:   p.proto.GetPackage(),
		}
	}

	return services
}

type tmplService struct {
	proto *descriptor.ServiceDescriptorProto
	pkg   string
}

func (svc *tmplService) Name() string {
	return svc.proto.GetName()
}

func (svc *tmplService) CamelName() string {
	return camelize(svc.proto.GetName())
}

func (svc *tmplService) ServiceName() string {
	if svc.pkg == "" {
		return svc.proto.GetName()
	}

	return svc.pkg + "." + svc.proto.GetName()
}

func (svc *tmplService) PackageName() string {
	if svc.pkg == "" {
		return svc.proto.GetName()
	}

	return svc.pkg
}

func (svc *tmplService) Methods() []*tmplMethod {
	methods := make([]*tmplMethod, len(svc.proto.GetMethod()))

	for i, proto := range svc.proto.GetMethod() {
		methods[i] = &tmplMethod{
			proto: proto,
		}
	}

	return methods
}

type tmplMethod struct {
	proto *descriptor.MethodDescriptorProto
}

func (m *tmplMethod) Name() string {
	return m.proto.GetName()
}

func (m *tmplMethod) InputArg() string {
	// name is prefixed with the package
	name := m.proto.GetInputType()
	parts := strings.Split(name, ".")

	return underscore(parts[len(parts)-1])
}

func (m *tmplMethod) InputType() string {
	return strings.TrimPrefix(m.proto.GetInputType(), ".")
}

func (m *tmplMethod) OutputType() string {
	return strings.TrimPrefix(m.proto.GetOutputType(), ".")
}

// camelize converts snake_case to CamelCase
func camelize(input string) string {
	parts := strings.Split(input, ".")

	for i, part := range parts {
		words := strings.Split(part, "_")

		for j, word := range words {
			runed := []rune(word)
			runed[0] = unicode.ToUpper(runed[0])

			words[j] = string(runed)
		}

		parts[i] = strings.Join(words, "")
	}

	return strings.Join(parts, "")
}

// underscore converts CamelCase to snake_case
func underscore(input string) string {
	buf := &bytes.Buffer{}

	// Iterate over the string. Lower case everything, and add an underscore
	// before any capital that's not the first.
	for i, char := range input {
		if unicode.IsUpper(char) && i > 0 {
			buf.WriteRune('_')
		}

		buf.WriteRune(unicode.ToLower(char))
	}

	return buf.String()
}

// pythonSrvTemplate provides a full template for the generated code.
const pythonSrvTemplate = `# Code generated by protoc-gen-twirp_python_srv {{.Version}}, DO NOT EDIT.
# source: {{.SourceFilename}}

import httplib
import json
from collections import namedtuple
from enum import Enum
from functools import partial

from google.protobuf import json_format
from google.protobuf import symbol_database as _symbol_database
from werkzeug.wrappers import Request, Response

_sym_db = _symbol_database.Default()

EndpointTypes = namedtuple("EndpointTypes", ["input", "output"])

class Errors(Enum):
    Canceled = "canceled"
    Unknown = "unknown"
    InvalidArgument = "invalid_argument"
    DeadlineExceeded = "deadline_exceeded"
    NotFound = "not_found"
    BadRoute = "bad_route"
    AlreadyExists = "already_exists"
    PermisionDenied = "permission_denied"
    Unauthenticated = "unauthenticated"
    ResourceExhausted = "resource_exhausted"
    FailedPrecondition = "failed_precondition"
    Aborted = "aborted"
    OutOfRange = "out_of_range"
    Unimplemented = "unimplemented"
    Internal = "internal"
    Unavailable = "unavailable"
    DataLoss = "data_loss"
    NoError = ""

    @staticmethod
    def get_status_code(code):
        return {
            Errors.Canceled: 408,
            Errors.Unknown: 500,
            Errors.InvalidArgument: 400,
            Errors.DeadlineExceeded: 408,
            Errors.NotFound: 404,
            Errors.BadRoute: 404,
            Errors.AlreadyExists: 409,
            Errors.PermisionDenied: 403,
            Errors.Unauthenticated: 401,
            Errors.ResourceExhausted: 403,
            Errors.FailedPrecondition: 412,
            Errors.Aborted: 409,
            Errors.OutOfRange: 400,
            Errors.Unimplemented: 501,
            Errors.Internal: 500,
            Errors.Unavailable: 503,
            Errors.DataLoss: 500,
            Errors.NoError: 200,
        }.get(code, 500)


class TwirpException(httplib.HTTPException):
    def __init__(self, code, message, meta={}):
        if isinstance(code, Errors):
            self.code = code
        else:
            self.code = Errors.Unknown
        self.message = message
        self.meta = meta


{{ range .Services -}}
class {{ .CamelName }}Impl(object): {{- range .Methods }}
    def {{ .Name }}(self, {{ .InputArg }}):
        raise TwirpException(Errors.Unimplemented, "{{ .Name }} is unimplemented")
{{ end }}

class {{ .CamelName }}Server(object):
    proto_codec_map = { {{- range .Methods }}
        "{{ .Name }}": EndpointTypes(
            input="{{ .InputType }}",
            output="{{ .OutputType }}",
        ),
        {{- end }}
    }

    def __init__(self, service, hooks=None):
        """Creates a new server for the {{ .Name }} service.

        Args:
            service: An object which implements methods matching
                the {{ .Name }} protobuf service.
            hooks: Optional object implementing any of the request
                lifecycle hooks protocol methods.
        """
        self.service = service
        self.hooks = hooks

        self.__package_name = "{{ .PackageName }}"
        self.__service_name = "{{ .ServiceName }}"
        self.__prefix = "/twirp/" + self.__service_name

    def __call__(self, environ, start_response):
        ctx = {
            "package_name": self.__package_name,
            "service_name": self.__service_name,
        }
        try:
            return self.handle_request(ctx, environ, start_response)
        except Exception as e:
            return self.handle_error(ctx, e, environ, start_response)

    @staticmethod
    def json_decoder(request, data_obj=None):
        body = request.get_data(as_text=False)
        data = data_obj()
        json_format.Parse(body, data)
        return data

    @staticmethod
    def json_encoder(value, data_obj=None):
        if not isinstance(value, data_obj):
            raise TwirpException(
                Errors.Internal,
                ("bad service response type " + str(type(value)) +
                 ", expecting: " + data_obj.DESCRIPTOR.full_name))

        resp = Response(json_format.MessageToJson(
            value, preserving_proto_field_name=True),
            headers=[("Content-Type", "application/json")])
        return resp

    @staticmethod
    def proto_decoder(request, data_obj=None):
        body = request.get_data(as_text=False)
        data = data_obj()
        data.ParseFromString(body)
        return data

    @staticmethod
    def proto_encoder(value, data_obj=None):
        if not isinstance(value, data_obj):
            raise TwirpException(
                Errors.Internal,
                ("bad service response type " + str(type(value)) +
                 ", expecting: " + data_obj.DESCRIPTOR.full_name))

        resp = Response(value.SerializeToString(),
                        headers=[("Content-Type", "application/protobuf")])
        return resp

    def get_endpoint_methods(self, request):
        (_, url_pre, rpc_method) = request.path.rpartition(self.__prefix + "/")
        if not url_pre or not rpc_method:
            raise TwirpException(
                Errors.BadRoute, "no handler for path " + request.path,
                {"twirp_invalid_route": "POST " + request.path},
            )
        func = getattr(self.service, rpc_method, None)
        if not func:
            raise TwirpException(
                Errors.Unimplemented, "service has no method " + rpc_method,
                {"twirp_invalide_route": "POST " + request.path})

        arg_types = self.proto_codec_map.get(rpc_method, None)
        if not arg_types:
            raise TwirpException(
                Errors.BadRoute,
                "unable to get argument type codecs for " + rpc_method,
                {"twirp_invalid_route": "POST " + request.path})
        input_obj = _sym_db.GetSymbol(arg_types.input)
        output_obj = _sym_db.GetSymbol(arg_types.output)

        ctype = request.headers['Content-Type']
        if ctype == "application/json":
            decoder = partial(self.json_decoder, data_obj=input_obj)
            encoder = partial(self.json_encoder, data_obj=output_obj)
        elif ctype == "application/protobuf":
            decoder = partial(self.proto_decoder, data_obj=input_obj)
            encoder = partial(self.proto_encoder, data_obj=output_obj)
        else:
            raise TwirpException(
                Errors.BadRoute, "unexpected Content-Type: " + ctype,
                {"twirp_invalid_route": "POST " + request.path},
            )

        return rpc_method, func, decoder, encoder

    def do_hook(self, ctx, hook_name):
        if not self.hooks:
            return
        hook = getattr(self.hooks, hook_name, None)
        if hook:
            hook(ctx)

    def handle_request(self, ctx, environ, start_response):
        request = Request(environ)
        self.do_hook(ctx, "request_received")

        http_method = request.method
        if http_method != "POST":
            raise TwirpException(
                Errors.BadRoute,
                "unsupported method " + http_method + " (only POST is allowed)",
                {"twirp_invalid_route": http_method + " " + request.path},
            )
        ctx["http_method"] = "POST"
        ctx["url"] = request.path
        ctx["content-type"] = request.headers["Content-Type"]

        endpoint, func, decode, encode = self.get_endpoint_methods(request)
        ctx["endpoint"] = endpoint
        self.do_hook(ctx, "request_routed")

        input_arg = decode(request)
        result = func(input_arg)
        response = encode(result)
        self.do_hook(ctx, "response_prepared")

        ctx["status_code"] = 200
        self.do_hook(ctx, "response_sent")

        return response(environ, start_response)

    def handle_error(self, ctx, exc, environ, start_response):
        response = Response()
        if isinstance(exc, TwirpException):
            err = {
                "code": exc.code.value,
                "msg": exc.message,
                "meta": {},
            }
            if exc.meta:
                err["meta"].update(exc.meta)
            err["meta"].update(ctx)
            code = exc.code
        else:
            err = {
                "type": "Internal",
                "msg": ("There was an error but it could not be "
                        "serialized into JSON"),
                "meta": {
                    "raw_error": repr(exc),
                },
            }
            err["meta"].update(ctx)
            code = Errors.Internal

        response.status_code = Errors.get_status_code(code)
        response.set_data(json.dumps(err))
        # Force json for errors.
        response.headers["Content-Type"] = "application/json"

        ctx['status_code'] = response.status_code
        self.do_hook(ctx, "error")

        return response(environ, start_response)
{{- end }}
`
